#ifndef MLCORE_UTILITIES_H
#define MLCORE_UTILITIES_H

#include <iterator>
#include <limits>
#include <sstream>
#include <vector>

namespace mlCore
{

/**
 * @brief Interface for classes used to initialize data for Tensors, ranges etc. The behaviour and returned values depend on the concrete implementation of the interface
 * 
 * @tparam ValueType Type of the values generated by the initializer
 */
template <typename ValueType>
struct ITensorInitializer
{
	virtual ValueType yield() const = 0;
	virtual bool canYield() const
	{
		return true;
	}
	virtual ~ITensorInitializer() = default;
};

/**
 * @brief Yields values from linear range
 * 
 */
template <class ValueType>
struct RangeTensorInitializer : public ITensorInitializer<ValueType>
{
	/**
	 * @brief Construct a new Range Tensor Initializer object
	 * 
	 * @param firstValue Initial value to be returned and appended with each yield
	 * @param step The increment factor of the initializer's value
	 * @param maxValue The border value at which the initializer stops 
	 */
	RangeTensorInitializer(ValueType firstValue,
						   ValueType step = 1,
						   ValueType maxValue = std::numeric_limits<ValueType>::max())
		: currentValue_(firstValue)
		, step_(step)
		, maxValue_(maxValue)
	{ }

	ValueType yield() const override
	{
		if(!canYield())
		{
			throw std::out_of_range("Cannot obtain value from RangeTensorYielder.");
		}

		ValueType out = currentValue_;
		currentValue_ += step_;
		return out;
	}

	bool canYield() const override
	{
		return currentValue_ <= maxValue_;
	}

private:
	mutable ValueType currentValue_;
	ValueType maxValue_;
	ValueType step_;
};

template <typename T>
std::string stringifyVector(const std::vector<T>& vect,
							const char* const openSign = "(",
							const char* const closeSign = ")")
{
	std::ostringstream serializingStream;
	serializingStream << openSign;
	std::copy(vect.cbegin(), vect.cend(), std::ostream_iterator<T>(serializingStream, ", "));
	serializingStream << closeSign;
	return serializingStream.str();
}

} // namespace mlCore

#endif